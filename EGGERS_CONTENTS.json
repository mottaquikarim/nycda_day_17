{"home":{"content":"# Promises (III)\n---\n*(Third time's the charm...right?)*\n\nWelcome to Lecture 17! Here's a brief class breakdown.\n\n#### Clone to your Machine\n---\n#### [Gif Search Engine](https://github.com/mottaquikarim/gifSearchEngine)\n\n**This has been updated to reflect the new code changes we made last lecture.**\n\n<p></p>\n\n#### [Live Class Notes](http://autosync.io/#/course/Taq/0)\n---\nWe are going back to Sublime Text! Please keep up with instructor notes via **AutoSync**.\n\n#### Learning Objectives\n---\n1. Understand how promises can help us wrangle asynch behavior\n\n#### To Do Today\n---\n\n#### [Warmup](#warmup)\n#### [Gif Search Engine](#gif-search-engine)\n#### [Promises](#promises)\n#### [Weather Forecast](#weather-forecast)\n#### [SoundCloud Jukebox](#soundcloud-jukebox)\n","idx":0},"title":{"content":"Promises","idx":1},"desc":{"content":"An introduction to functional asynch behavior","idx":2},"warmup":{"content":"# Warmup\n---\n\n#### Problem 1\n---\n\nWrite a function that takes in N arguments and returns the largest number.\n\nIf any of those arguments are **NOT** numbers, ignore.\n\nIf no numbers are provided, return **null**.\n\nThis function should work if you pass in an array OR if you pass in raw arguments (look at example below):\n\n```js\ngetMax([1,2,3,4,5]); // returns 5\ngetMax(1,2,3,4,5); // returns 5\n```\n\n**Notice** that the first one passes in an array and second passes in just arguments.\n\n#### Problem 2\n---\n\nImplement your own forEach function.\n\n1. It should take two args, an `array` and a `callback`\n2. does not return anything\n\nFor example:\n\n```js\nforEach(['a', 'b', 'c'], (current, index) => {\n    console.log(current, index);\n});\n// 'a', 0\n// 'b', 1\n// 'c', 2\n```\n\n**Stretch Goal**: Implement a function called `map`, that works as follows:\n\n```js\nconst newArr = map([7,8,9], (curr, i) => {\n    return curr ** 3;\n});\n// [343, 512, 729]\n```\n\n#### Problem 3\n---\n\nIn the **gifSearchEngine** project that you cloned (if now, **[do this now](https://github.com/mottaquikarim/gifSearchEngine)**), begin implementing **pagination**.\n\n**Step 1**: after a search occurs, right now the code requests the first 10 results.\n\nWrite some code that will take these results and display the image URLs in the browser as **img** tags.\n\n**Step 2**: below your **img** tags, add a link called **next** (programmatically) that, when clicked, will do a gifSearch for the **next 10** results in this same search (and display **those** results).\n\n**Question**: notice that delay when you click on the **next** button? How could you prevent that?\n ","idx":3},"gif-search-engine":{"content":"# Gif Search Engine\n---\n\n**Goal**: We will build a web app that allows us to easily search for gifs via the **Giphy** API.\n\n#### How It Should Work\n---\n\n1. Searchable input field the responds to both the **enter** keystroke **and** a **click** even on a submit button.\n2. On search initialization, **both** the submit button and the input field are **disabled**\n3. AJAX call is made to **Giphy** API to retrieve data.\n4. The **API response** is processed with a for loop and the gif images are displayed on the page.\n5. **Pagination**! We support pagination in this app - meaning, user will see first **10 results** but will have the ability to **load more**.\n\n#### Stretch Goals\n---\n\n1. **Instant** pagination. Clicking on the \"load more\" will instantly pull in the next 10 results without any additional wait time for the user.\n2. **Click to copy**. User can click on any gif to copy the image address.\n3. **Save to favorites**. User can \"save\" some of their favorite gifs **locally** and on subsequent page loads, have them appear on the side rail for quick reuse.","idx":4},"promises":{"content":"# Promises\n---\n\nBefore we being with promises, let's talk about a slightly different problem: **callbacks**.\n\nNow, generally, callbacks are pretty solid. Incredibly useful, even. But the problem starts when we have the following:\n\n```js\ndoAjaxCall('some_url', () => {\n    // ... stuff here\n    doAjaxCall('some_url_2', () => {\n        // ... stuff here\n        doAjaxCall('some_url_3', () => {\n            // ...kill me now...\n        });\n    });\n});\n```\n\n**^^^** in the business, we call that a callback-apocalypse. It looks ridiculous but based on what we know so far, it is an **unfortunate** consequence of working with asynchronous actions. For example, if you wanted to look up the weather data for NYC, SF, and Chicago - but you had to do them in order, you'd have no choice **but** to do something like above.\n\n#### Enter the Promise\n---\n\nA **promise** in javascript is an **object** with five function properties:\n\n1. **then**\n2. **catch**\n3. **resolve**\n4. **reject**\n5. **all**\n\nIf a function returns a **promise**, we can **pull out the callback function** from the arguments list of the function. This will **flatten** out our call chain and simplify a bunch of things.\n\nObserve (^ the same code as above, but now with promises):\n\n```js\ndoAjaxCall('some_url')\n    .then(() => doAjaxCall('some_url_2'))\n    .then(() => doAjaxCall('some_url_3'))\n    .then(() => {\n        // this callback is run when\n        // *ALL* three are done\n    });\n```\n\nA lot neater, right?\n\n...But what if you want to do stuff with the ajax call results? After all, that's the point of doing an ajax call.\n\nConsider this alternate use case of promises (the following example is the same as above, but a bit more verbose + includes opportunities to use the results of the ajax calls)\n\n```js\nconst callOne = doAjaxCall('some_url');\nconst callTwo = callOne.then((results1) => {\n    return doAjaxCall('some_url_2');\n});\nconst callThree = callTwo.then((results2) => {\n    return doAjaxCall('some_url_3');\n});\n\nPromise.all(callOne, callTwo, callThree)\n    .then((allResults) => {\n        console.log(allResults);\n        // ^^ contains the results from \n        // all three calls, in an array\n    });\n```\n\n#### Promise States\n---\n\nAll promises will have one of three states:\n\n1. pending\n2. fulfilled\n3. rejected\n\nThe **then** method runs when a promise is **fulfilled**.\n\nThe **catch** method will run if any of your promises in the chain is **rejected**.\n\nThe **resolve** and **reject** methods can be run to create a promise and immediately set the state to **fulfilled** or **rejected**.\n\nthe **all** method can be used to wrap a promise around multiple promises. (ie: have a promise that resolves **when** all the passed in promises are resolved).\n\n#### Challenge\n---\n\nWrite your own implementation of `Promise.all`.\n\n#### Additional Notes\n---\n\nNotes from NYCDA curriculum.\n\n#### Creating a Promise\n---\n- New promises take a function that has two function arguments - resolve and reject\n- Promise functions are intended to do some work, _eventually_ calling resolve or reject\n\n```js\nvar promise = new Promise((resolve, reject) => {\n  // perform an action\n  // this could be any synchronous or asynchronous operation\n\n  // if there was an error\n  reject(error);\n\n  // if everything went well\n  resolve(result);\n});\n```\n#### Using a Promise: `promiseInstance.then()`\n---\n\n- All promise instance get a `.then()` method that allow you to handle promise resolution\n- The `.then()` callback receives the result given by what was passed to the promise's `resolve`\n- Once a promise is fulfilled (when `resolve` is called), the fulfillment value is passed to the `.then()` handler\n\n#### Example: Using `promiseInstance.then()`\n---\n```js\n// create a promise\nvar promise = new Promise((resolve, reject) => {\n  // after a waiting a second,\n  setTimeout(() => {\n    // resolve the promise with a message\n    resolve('hello world!');\n  }, 1000);\n});\n\npromise.then((result) => {\n  // prints \"hello world!\" after 1s\n  console.log(result);\t\n});\n```\n\n#### Using a Promise: `promiseInstance.catch()`\n---\n\n- All promise instances also get a `.catch()` method that allow you to handle promise rejection\n- The `.catch()` callback receives the result given by what was passed to the promise's `reject`\n- Typically, `.catch()` is called with an `Error` (or a type that inherits from `Error`)\n\n\n#### Example: Using `promiseInstance.catch()`\n---\n\n```js\n// create a promise\nvar promise = new Promise((resolve, reject) => {\n  // after a waiting a second,\n  setTimeout(() => {\n  // reject the promise with an Error\n    reject(new Error('uh oh!'));\n  }, 1000);\n});\n\npromise.catch((err) => {\n  // prints the error \"uh oh!\" with the stack after 1s\n  console.log(err);\t\n});\n```\n\n#### Using a Promise: `Promise.resolve()`\n---\n\n- Instead of creating a Promise, you can use the static method `.resolve()` to fulfill values\n- Makes a Promise that is already resolved to the value you pass\n\n\n#### Example: Using `Promise.resolve()`\n---\n\n```js\n// create a promise using `.resolve()`\nvar promise = Promise.resolve('hello world!');\n\npromise.then((result) => {\n  // prints \"hello world!\"\n  console.log(result);\t\n});\n```\n\n#### Using a Promise: `Promise.reject()`\n---\n\n- Again, instead of creating a Promise, you can use the static method `.reject()`to create a rejected Promise\n- Like `.resolve()`, this creates a promise that is already in a rejected state, passing the error\n\n\n#### Example: Using `Promise.reject()`\n---\n\n```js\n// create a promise using `.reject()`\nvar promise = Promise.reject(new Error('uh oh'));\n\npromise.catch((err) => {\n  // prints \"hello world!\"\n  console.log(err);\t\n});\n```\n\n#### Function Composition/Chaining\n---\n\n- `.then()` and `.catch()` both return Promises\n- This means that the return values can call `.then()` and `.catch()` as well, chaining the methods together in an operation known as composition\n- Chaining allows Promises to allow for more complex behavior\n- Note that values must be returned from the `.then()` handler \n- Returned values can be promises or any other object, function, or primitive\n\n\n#### Example: Chained `then` call\n---\n\n\n```js\nvar promise = Promise.resolve('hello')\n  .then((str) => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve(`${str} there`);\n      }, 1000);\n    });\n  })\n  .then((str) => {\n    return `${str} world!`;\n  })\n  .then((str) => {\n    //prints \"hello there world!\"\n    console.log(str);\n    //the `promise` variable above will eventually\n    //be a fulfilled promise with `str` as its value\n    return Promise.resolve(str);\n  });\n```\n\n---\n\n","idx":5},"weather-forecast":{"content":"# Weather Forecast\n---\n\nTo properly pull this off, you will need a quick NPM module from Node.js.\n\nRun this in your terminal:\n\n```bash\nnpm install http-server -g\n```\n\n#### General Overview\n---\n\nWe are building a weather app clone. Here are the main features:\n\n1. When the user hits the page, we will use the **geolocation** api native to most browsers to get the **lat**, **long** coordinates of the user.\n2. Having gathered this data, we will then hit the **OpenWeatherMap** API and retrieve the **current** weather conditions.\n * Having retrieved the data, we will display the information on the page for the user to see.\n3. Then, we will hit the same **OpenWeatherMap** API to retrieve the 5 day forecast.\n * we will display this forecast to the user as well, omitting the weather information for the current day\n\n#### Stretch Goals\n---\n* Once we retrieve the current weather condition, we hit the Flickr API to pull in an appropriate image reflecting the weather conditions\n* Once we gather the user location, we store it locally.\n* On clicking into each one of the 5-day forecast items, we pull in Flickr API image reflecting conditions for that day. We also display the 3 hour forecast for conditions over the entire day...?\n\n#### Task 1\n---\n\n**NOTE**: you will need to run your `http-server` call to pull this off. Run something along the lines of:\n\n```bash\nhttp-server -P 8000\n```\n\nThe browser geolocation API is an asychronous, callback based method that retrieve the lat and long of the user. **[Read the docs here](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation)**.\n\n**Create a function** that retrieves this information and returns a **promise** that is returned once this data is retrieved.\n\n#### Task 2\n---\n\nWrite a generic **GET** function that makes an AJAX call to any url you pass in. It should also account for any number of parameters you pass in to the GET URL. (You are free to design the feature however you'd like). Finally, this function must **return a promise** so that we can chain multiple GET calls to different API endpoints and services. \n\n\n","idx":6},"soundcloud-jukebox":{"content":"# SoundCloud Jukebox\n---\n\nWe will build **[this](https://mottaquikarim.github.io/soundcloud-jukebox/)**.\n\n#### Starter Coder\n---\nAdd your own js files, etc\n\n```html\n<!doctype html>\n<html>\n<head>\n\t<meta charset='utf-8'>\n    <meta name='viewport' content='width=device-width, initial-scale=1.0;'>\n    <title>SoundCloud Player</title>\n    <link rel='stylesheet' href='styles/semantic.min.css'>\n    <link rel='stylesheet' href='styles/main.css'>\n\n</head>\n<body id=\"soundcloud-player\">\n\n<div class=\"ui container col\">\n    <div class=\"col__left js-playlist\">\n        \n    </div>\n    <div class=\"col__right\">\n        <div class=\"main\">\n            <div class=\"ui massive icon input\">\n                <input type=\"text\" placeholder=\"Search for a song or artist...\" class=\"js-search input__search\">\n                <i class=\"search icon js-submit\"></i>\n            </div>\n\n            <div class=\"search-results js-search-results ui cards\">\n                <h2>Please type in a search value!</h2>\n            </div>\n        </div>\n    </div>\n</div>\n\n<script src=\"javascript/main.js\"></script>\n\n</body>\n</html>\n\n```\n\n```css\n/* CURRENTLY IN: styles/main.css */\nhtml, body {\n\theight: 100%;\n\twidth: 100%;\n\tmin-height: 100%;\n}\n\n#soundcloud-player .col {\n\tposition: fixed;\n\theight: 100%;\n\twidth: 100%;\n\ttop: 0;\n\tleft: 0;\n}\n\n#soundcloud-player .col__left {\n\twidth: 20%;\n\theight: 100%;\n\tbackground-color: #292929;\n\toverflow: auto;\n\n\tposition: fixed;\n\tleft: 0;\n\ttop: 0;\n\n\tmin-width: 200px;\n\tz-index: 1;\n}\n\n#soundcloud-player .col__right {\n\twidth: 100%;\n\theight: 100%;\n\toverflow: auto;\n\n\tposition: fixed;\n\tleft: 0;\n\ttop: 0;\n\n\tbox-sizing: border-box;\n\tpadding-left: 20%;\n}\n\n#soundcloud-player .main {\n\tbox-sizing: border-box;\n\tpadding: 30px;\n\tmargin: 30px;\n}\n\n#soundcloud-player .input {\n\twidth: 100%;\n}\n\n#soundcloud-player .input__search {\n\twidth: 100%;\n\tdisplay: block;\n}\n\n#soundcloud-player .search.icon {\n\tpointer-events: initial;\n\tcursor: pointer;\n}\n\n#soundcloud-player .search-results {\n\tjustify-content: center;\n    margin-top: 30px;\n}\n\n```","idx":7},"__list__":["home","title","desc","warmup","gif-search-engine","promises","weather-forecast","soundcloud-jukebox"]}